<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The CooPLa Project">
    <meta name="author" content="Nuno Oliveira">

    <title>The CooPLa Project</title>

    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="css/modern-business.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="font-awesome-4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="index.html">The CooPLa Project</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            <li>
                                <a href="coopla.html">CooPLa</a>
                            </li>
                            <li>
                                <a href="recoopla.html">ReCooPLa</a>
                            </li>
                            <li>
                                <a href="publications.html">Publications</a>
                            </li>
                        </ul>
                    </li>
                    
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tools <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            <li>
                                <a href="tools.html">CooPLa Editor</a>
                            </li>
                            <li>
                                <a href="tools.imcreotool.html">IMCREOTool</a>
                            </li>
                            <li>
                                <a href="tools.reconf_engine.html">Reconfiguration Engine</a>
                            </li>
                            <li>
                                <a href="tools.reoimporter.html">Reo XML Importer</a>
                            </li>
                            <li>
                                <a href="tools.reoexporter.html">Reo XML Exporter</a>
                            </li>
                            <li>
                                <a href="tools.rslexporter.html">RSL for Vereofy</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="team.html">Team</a>
                    </li>
                    <!--li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Portfolio <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            <li>
                                <a href="portfolio-1-col.html">1 Column Portfolio</a>
                            </li>
                            <li>
                                <a href="portfolio-2-col.html">2 Column Portfolio</a>
                            </li>
                            <li>
                                <a href="portfolio-3-col.html">3 Column Portfolio</a>
                            </li>
                            <li>
                                <a href="portfolio-4-col.html">4 Column Portfolio</a>
                            </li>
                            <li>
                                <a href="portfolio-item.html">Single Portfolio Item</a>
                            </li>
                        </ul>
                    </li-->
                    <!--li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Blog <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            <li>
                                <a href="blog-home-1.html">Blog Home 1</a>
                            </li>
                            <li>
                                <a href="blog-home-2.html">Blog Home 2</a>
                            </li>
                            <li>
                                <a href="blog-post.html">Blog Post</a>
                            </li>
                        </ul>
                    </li-->
                    <!--li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Other Pages <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            <li>
                                <a href="full-width.html">Full Width Page</a>
                            </li>
                            <li>
                                <a href="sidebar.html">Sidebar Page</a>
                            </li>
                            <li>
                                <a href="faq.html">FAQ</a>
                            </li>
                            <li>
                                <a href="404.html">404</a>
                            </li>
                            <li>
                                <a href="pricing.html">Pricing Table</a>
                            </li>
                        </ul>
                    </li-->
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

        <!-- Page Heading/Breadcrumbs -->
        <div class="row">
            <div class="col-lg-12">
                <h1 class="page-header">CooPLa
                    <small><b>Coo</b>rdination <b>P</b>atterns <b>La</b>nguage</small>
                </h1>
                <ol class="breadcrumb">
                    <li><a href="index.html">Home</a>
                    </li>
                    <li class="active">CooPLa</li>
                </ol>
            </div>
        </div>
        <!-- /.row -->

        <!-- Content Row -->
        <div class="row">
            <div class="col-lg-12">
                <p>
                    The CooPLa language was thought for software architects. It endows them with a tool for, in the abstract, design the coordination between components or services in the context of service-oriented architectures, or more generically, component-based software.
                </p>
                <p>
                    Coordination is the fundamental activity in software architectures design. It defines how each component of the system will interact with the others. In this sense, a <i>coordination structure</i> encapsulates the policies and protocols that restrict and guide the communication between the components.
                </p>
                <p>
                    While there are several approaches to abstract how coordination structures are defined (e.g., tuple-space, message-driven, event-driven, etc.) one of the most acclaimed is the channel-based. Traditionally, a channel-based approach assumes the coordination to be made from the exterior of the components (exogenous coordination), i.e., the components are agnostic of their surroundings, including with which other components they will interact. 
                    Moreover, it is also assumed that channels are building-blocks that can be composed to form complex coordination structures and that each channel presents exactly two ends where data is written and read by the attached components or other channels.</p>
                <p>
                    Some coordination approaches also take into account the performance aspects of the systems. This is to face the needs of constructing dependable systems, where performance is usually a challenging characteristic. In the channel-based approaches of coordination, channels are overloaded with notions of quality of service, notably, their processing delays (i.e., the time needed process data).
                </p>
                
                <br>
                
                <p>
                    The model underlying CooPLa is set on a channel-based approach for coordination. It takes a loose definition of channel, though: channels have more than two ends; and it does not assume either any specific coordination formalism like <a href="http://reo.project.cwi.nl/reo/" target="_blank">Reo</a> or <a href="http://www-verimag.imag.fr/Rigorous-Design-of-Component-Based.html?lang=en" target="_blank">BIP</a>; the behaviour of a channel is abstractly defined via automata. The model underlying CooPLa, is essentially a graph where edges are channels with an identifier and a behaviour, and nodes are either points for composition of other channels or points for attaching components (the so called interface of the coordination structure).
                </p>
                <p>
                    CooPLa enables the definition of channels, patterns and (stochastic) instances as the grammar below shows:
                </p>

                <pre>
coopla              : import* element* 
element             : channel_def | pattern_def | stochastic_def
import              : 'import' FILE_PATH ';'

channel_def         :'channel' channel_sig extension? '{' channel_body '}'
channel_sig         : ID dimensions? '(' ports? ':' ports? (':' ID '=' condition)? ')'
dimensions          : '@' ( ID | INT )
                    | '~' ( ID | INT ) ( ',' ( ID | INT ) )*
ports               : ID ( ',' ID )*
condition           : '<' ID ( ',' ID )* '>'
extension           : 'extends' ID
channel_body        : state_def? ( flow_def ';' )+ 
state_def           : 'state' ':' ID ';' 'observers' ':' ID ( ',' ID )* ';'
flow_def            : requests '->' flow_type
requests            : request ( ',' request )* 
request             : '!'? ID
flow_type           : normal_flow ( '|' normal_flow)? flow_label  
                    | ID '?' flow_type : flow_type 
normal_flow         : 'flow' ( ID | 'NULL' ) 'to' '@'? ( ID | 'NULL' )
flow_label          : '#' ID

pattern_def         : 'pattern' pattern_signature '{' pattern_body '}' 
pattern_signature   : ID '(' ports? ':' ports? ')'
pattern_body        : 'use' ':' pattern_decls 'in' ':' pattern_comps
pattern_decls       : ( reference_sig 'as' ID (',' ID)* ';' )+
reference_sig       : ('(' ID ')')? channel_sig
pattern_comps       : ( port_definition ';' )+ ( join_operation ';' )+ 
port_definition     : ID '=' (p_acc | join_operation)
p_acc               : ID '.' ID
join_operation      : 'join' port_access_list 'as' ID
                    |  'xor' port_access_list2 'as' ID
port_access_list    : '[' p_acc ( ',' p_acc )* ']'
port_access_list2   : '[' p_acc+ ':' p_acc ',' p_acc (',' p_acc)* ']'

stochastic_def      : 'stochastic' ID  '@' stochastic_list ID
stochastic_list     : '{' stoch_elem+ '}'  
stoch_elem          : ID ('#' ID)? '=' stoch_val ';'   
stoch_val           : FLOAT
                    |  '(' FLOAT ',' FLOAT ')' <!--
                   --> </pre>
            </div>
        </div>
        <!-- /.row -->



        <div class="row">
            <div class="col-lg-12">
                <h2 class="page-header">Details and Examples</h2>
            </div>
            <div class="col-lg-12">

                <ul id="myTab" class="nav nav-tabs nav-justified">
                    <li class="active"><a href="#channels" data-toggle="tab"><i class="fa fa-chain"></i> Channels</a>
                    </li>
                    <li class=""><a href="#patterns" data-toggle="tab"><i class="fa fa-puzzle-piece"></i> Patterns</a>
                    </li>
                    <li class=""><a href="#instances" data-toggle="tab"><i class="fa fa-code-fork"></i> Stochastic Instances</a>
                    </li>
                </ul>

                <div id="myTabContent" class="tab-content">
                  
                    <!--CHANNEL-->
                    <div class="tab-pane fade active in" id="channels">
                        <h4>Channels</h4>
                        <p>
                            A channel is defined by the reserved word <code>channel</code> followed by a signature and a body. A signature mainly defines the 
                            <code>ID</code> of the channel (its name), and the input and output ports (separated by <code>:</code>). 
                        </p>  
                        <p>
                            In the signature, one may further specify whether the channel is
                        </p>
                        <ul>
                            <li>
                                <b>structured<sup>*</sup></b>: a dimension <code>~N</code> of the internal structure of the channel has to be specified after the channel name. This is used for channels that present internal state;
                            </li>
                            <li>
                                <b>timed</b>: a time <code>@T</code> has to be specified after the channel name. This is used for imposing delays in data transmission;
                            </li>
                            <li>
                                <b>conditioned</b>: a pattern condition <code>cond=<...></code> has to be specified after the channel ports (separated from the output ports with a <code>:</code>. This is used to condition the behaviour of a channel to certain data structures.
                            </li>
                            <li>
                                <b>extension</b>: a base channel has to be specified after the pattern ports (and conditions). 
                                The construction <code>extends < channel_name > </code> is used to define it. In this case, the channel inherits the behaviour of the base channel.
                            </li>
                        </ul>
                        <p>
                            <sup>*</sup> Whenever a channel is structured, a definition of that structures has to be specified in the body of the channel. This definition assumes
                        </p>
                        <ul>
                            <li>the structure name: <code>state: < sate_name > </code>and </li>
                            <li>the set of state observers (predicates over the structure): <code>observers: < set_of_names ></code>.</li>
                        </ul>
                        <p>
                            These names are assumed to be references to data structures and methods defined in an external programming language.
                        </p>
                        <br/>
                        <p>
                            Besides the structure definitions, the body of a channel is essentially a list of flows. Each flow define how the channel behaves to <i>stimuli</i> (intentions to read from and write to the channel ends) on its interface (and internal structure, if present). A flow is specified as <code>P->F</code>, where P is a set of channel ends (representing where stimuli exist) and/or state observers evaluating to true (possibly negated with <code>!</code>). 
                        </p>
                        <p>
                            A flow may be
                        </p>
                        <ul>
                            <li><b>normal</b>: follows the form <code>flow p1 to p2</code>, where p1,p2 are ports of the channel, the state name or the special point of the channel where data is lost or automatically produced <code>NULL</code>. This specifies that data flows (atomically) from point p1 to point p2;</li>
                            <li><b>atomically-synchronised</b>: follows the form <code>f1 | f2</code>, where f1,f2 are normal flows;</li>
                            <li><b>conditioned</b>: follows the form <code>cond ? f1 : f2</code>, where f1,f2 are normal flows and cond is the data structure pattern condition defined in the channel signature.</li>
                        </ul>
                        <p>
                            Each flow may have associated a flow label (<code>#< label ></code>), which is used for further reference to that flow. For instance, it is used to assign a stochastic value describing the processing delay performance characteristic of that flow.
                        </p>
                        <p>
                            A timed channel will directly specify a clock in its flows. Example, <code>flow p1 to@T p2</code> specifies that data flow from point p1 to point p2, after T units of time have passed.
                        </p>
                        <br/>
                        <br/>
                        <h4>Examples</h4>

                        <div class="row">
                            <div class="col-md-4">
                                 <pre>
channel sync(a:b) {
  a,b -> flow a to b #ab;
}        <!--
                            --> </pre>
                            </div>
                            <div class="col-md-8">
                                 <a id="sync_channel"></a>
                                    <p>
                                        The sync channel is read as a structure with input port a and output port b. Whenever there are IO requests pending at both ports simultaneously, then data flows from a to b.
                                    </p>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <pre>
channel lossy(a:b) extends sync {
  a,!b -> flow a to NULL  #aL;
}        <!--
                        -->     </pre>
                            </div>
                            <div class="col-md-8">
                                <p>
                                    The lossy channel extends sync with an extra flow: whenever there is a write (input) request at port a and no read (output) request at port b (notice the use of <code>!</code> to convey negation), then data is lost (\ie it flows from a to NULL).
                                </p>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <pre>
channel fifo~N(a:b){
  state: buffer; observers: E, F;     
  a,!F -> flow a to buffer # aB;
  !E,b -> flow buffer to b #Bb;
}       <!--
                        -->     </pre>
                            </div>
                            <div class="col-md-8">
                                <p>
                                    The fifo channel is a structure with input port a, output port b, a state named buffer with dimension N and observers E and F that check whether buffer is (E)empty and (F)ull, respectively. The behaviour of this channel is  defined taking into account the pending requests at the ports as well as the configuration of its internal structure. 
                                </p>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <pre>
channel drain(a,b:)  {
  a,b -> flow a to NULL  
                | 
        flow b to NULL  #ab;
}       <!--
                        -->     </pre>
                            </div>
                            <div class="col-md-8">
                                <p>
                                    The drain channel expects simultaneous stimuli at its two input ports; whenever this clause is fulfilled, data flows atomically synchronised (notice the use of construct <code>|</code>) from each of these ports to NULL, being lost.
                                </p>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <pre>
channel shiftFifo~N(a:b) extends fifo {
  a, F -> flow buffer to NULL 
                   |  
          flow a to buffer #aBF;
}      <!--
                        -->     </pre>
                            </div>
                            <div class="col-md-8">
                                <p>
                                    The shiftFifo channel inherits from the fifo channel. Notice that interface is equal and it also defines an internal structure, but it does not redefine the reference name and the observers for such structure. Behaviourally, it defines a new flow rule expressing that whenever there is an input stimulus at port a and the buffer is full, a datum in buffer is lost and the datum in a flows to buffer.
                                </p>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <pre>
channel filter(a:b:c=<_,_>) {
  a,b -> c ? flow a to b #ab
                  : 
            flow a to NULL #aL ; 
}      <!--
                        -->     </pre>
                            </div>
                            <div class="col-md-8">
                                <p>
                                    The filter channel presents a signature added of a datatype pattern c that matches data of sort pair (with components of any sort). This pattern is used in the definition of its flow rule. The latter expresses that whenever there are pending requests at both ports of the channel, if the sort of the data to be written matches pattern c, then data flows from a to b; otherwise it is lost. 
                                </p>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <pre>
channel timed@T (a:b) {
  a,b -> flow a to@T b #ab;
}     <!--
                        -->     </pre>
                            </div>
                            <div class="col-md-8">
                               <p>
                                    The timed channel is defined with a clock. Such clock imposes a delay T on the flow of data from ports a to b, whenever there are IO stimuli on the channel interface.
                               </p>
                            </div>
                        </div>
                         <div class="row">
                            <div class="col-md-4">
                                <pre>
channel router (a: b,c) {
  a,b,!c -> flow a to b #ab;
  a,c,!b -> flow a to c #ac;
  a,b,c  -> flow a to b #allab;
  a,b,c  -> flow a to c #allac;
}     <!--
                        -->     </pre>
                            </div>
                            <div class="col-md-8">
                               <a id="router_channel" ></a>
                               <p>
                                    The router is presented as a structure with one input port and two output ports. Notice also the existence of two flow rules that are triggered whenever there are pending requests at all the channel ports. This explicitly expresses non-deterministic behaviour of the channel. Consequently, data will flow non-deterministically from port a to either port b or port c.
                               </p>
                            </div>
                        </div>
                                
                    </div>






                    <!--PATTERN-->
                    <div class="tab-pane fade" id="patterns">
                        <h4>Patterns</h4>
                        <p>
                            A pattern (i.e., a coordination pattern) is defined by the reserved word <code>pattern</code> followed by a signature and a body. A signature defines the <code>ID</code> of the pattern (its name), and the input and output ports (separated by <code>:</code>).
                        </p>
                        <p>
                            The body of a pattern defines the interconnections between channels and previously defined patterns. This is where the coordination graph is obtained. Two phases are considered: the instantiation and the configuration.
                        </p>

                        <br/>
                        <h5>Instantiation phase</h5>
                        <p>
                            The <i>instantiation</i> phase is initiated by the reserved word <code>use:</code>. In this phase channels and patterns are instantiated as variables are in traditional programming languages. 
                        </p>
                        <p>
                            The instantiation takes the full signature of the channel (or pattern) to define the type of the instances. The full signature is used to provide logic names to refer to the ports of the channels (or patterns), as well as to define concrete values for structure dimensions, clock times and data structure condition patterns. For channels that define a structure it is mandatory to specify which state observer holds at its initial configuration.
                        </p>

                         <br/>
                        <h5>Configuration phase</h5>
                        <p>
                            The <i>configuration</i> phase is initiated by the reserved word <code>in:</code>. In this phase the graph of elements is assembled after the concrete definition of the pattern interface.
                        </p>
                        <p>
                            The definition of the pattern interface is the simple assignment of the logical instance ports to the names of the pattern ports specified in the signature. The logical ports instances are accessed via <code>el.p</code>, where el is the name of an instance declared in the instantiation phase and p is a logical name given to one of the instance ports. 
                        </p>
                        <p>
                            The assembling of the coordination structure is essentially made by joining ports of the instances: <code>join [p1,p2...] as j</code>, where p1,p2,... are accesses to the ports of the instances, and j is a new graph node. CooPLa also provides <code>xor [p1,p2,... : p3,p4,...] as x</code> to perform the assembly of instances. Both constructs define new graph nodes. The latter adds a semantic overload of an <i>exclusive or</i> data router. This is, in fact, a shorthand to defining a channel or pattern with such a behaviour (e.g., router channel) and connect its ports to the ports of other channels.
                        </p>

                       <br/>
                        <br/>
                        

                        <h4>Example</h4>

                         <div class="row">
                            <div class="col-md-4">
                                 <pre>
pattern Sequencer (a : b, c) {
  use :
    sync(i:o) as s1, s2, s3;
    (E)fifo~1(i:o)  as f1;
  in:
    a  = s1.i
    b  = s2.o; 
    c  = s3.o;
    join [s1.o, s2.i, f1.i] as hij;
    join [f1.o, s3.i] as kl; 
}        <!--
                            --> </pre>
                            </div>
                            <div class="col-md-8">
                                <p>
                                    The Sequencer pattern is defined as a structure with input port a and output ports b and c. 
                                </p>
                                <p>
                                    In the instantiation phase, there are defined three sync channels with logical reference names i and o, to the channel ends a and b, as defined in the Channels tab sync example. Similarly, one instance of the fifo channel is declared. Notice the concrete definition of a structure dimension and the initial state of the internal structure.
                                </p>
                                <p>
                                    In the configuration phase, the first three lines define how the interface of the Sequencer pattern is attached to the composing instances. The remaining lines define two nodes of the graph that result by the junction of the ends of the channel instances.
                                </p>
                                <p>
                                    This simple example shows everything about coordination patterns definition. 
                                </p>


                            </div>
                        </div>

                    </div>







                    <!--STOCHASTIC-->
                    <div class="tab-pane fade" id="instances">
                        <h4>Stochastic Instances</h4>
                        <p>
                            A stochastic instance (of a coordination pattern) is defiend by the reserved word <code>stochastic</code> followed by the name of the pattern of which the instance belongs, list of its stochastic values, and the <code>ID</code> of the instance (its name). 
                        </p>
                        <p>
                            A stochastic instance is a coordination pattern assigned with concrete stochastic values that define processing delays of channels, read and writing delays of nodes and environment information (in particular stimuli arrivals) that is associated to the interface of that pattern. 
                            In CooPLa, it is assumed that delays and arrivals are modelled by <a href="http://en.wikipedia.org/wiki/Exponential_distribution" target="_blank">exponential distributions</a>. Since these distributions only require a parameter -- the rate, a floating point value expressing the number of events occur per unit of time -- then this is the value expected by CooPLa in the list of stochastic values of the created instance. 
                        </p>
                        <p>
                            The stochastic values are assigned to ports, nodes and channels following notation <code>name @ value</code>, name is one of
                            <ul>
                                <li><b>port</b> -- a reference to a port in the interface of the pattern being instantiated;</li>
                                <li><b>node</b> -- a reference to a node as created by the <code>join</code> or <code>xor</code> operations and </li>
                                <li><b>channel</b> -- a reference to a flow label defined in the body of each channel that is part of the pattern being instantiated. In this case, the name is <code>n#l</code>, where n is the name of an instance of a channel declared in the pattern instantiation phase and l is a label defined in the body of that channel.</li>
                            </ul>
                            and value is either a floating point number for ports and channels, and a pair <code>(r,w)</code> for nodes, where r and w are also floating point numbers modelling the delay of reading and writing data from and to a channel, respectively.
                        </p>

                        <br/>
                        <br/>
                        
                        <h4>Example</h4>
                        <div class="row">
                            <div class="col-md-4">
                                 <pre>
stochastic Sequencer {
  a       @ 100.0;
  b       @ 10.0;
  c       @ 90.0;
  s1#ab   @ 1000.0;
  s2#ab   @ 500.50;
  s3#ab   @ 1000.0;
  f1#aB   @ 980.45;
  f1#Bb   @ 1500.0;
  hij     @ (100000.0, 150.50);
  kl      @ (100000.0, 99.0);
} sseq <!--
                            --> </pre>
                            </div>
                            <div class="col-md-8">
                                <p>
                                    In this example, a stochastic instance of a Sequencer coordination pattern with name sseq is specified. 
                                </p>
                                <p>
                                    The first three lines define the rate at which stimuli from the environment arrive to each of the ports of that instance. For example, stimuli arrive to each port at a rate of 100 per unit of time. 
                                </p>
                                <p>
                                    The next five lines define the channel delays. Notice how the labels defined for the examples in the Channels tab are accessed here. These values express, in fact, how many items the channel is able to process per unit of time. Using the inverse of each number it is obtained the time that the channel needs to process each data time. 
                                </p>
                                <p>
                                    The final two lines define the stochastic values for the internal nodes. These are not required to be expressed, because it is normal to assume that internal nodes read and write data instantaneously. However, CooPLa allows to define them in order to more faithfully represent real world systems.
                                </p>

                            </div>

                        </div>
                
                    </div>

                </div>
            </div>
        </div>


        <hr>

       <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>&copy; CooPLa Team 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery Version 1.11.0 -->
    <script src="js/jquery-1.11.0.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

    <script type="text/JavaScript">
        
    </script>

</body>

</html>
